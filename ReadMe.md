# Кейс: платформа голосования

**Обзор и назначение системы/продукта**.
Есть идея в качестве baby blockchain создать платформу голосования, пользователи которой это граждане Украины и только.
Назначением системы является укрепление социологии внутри государства.
То есть, выборы президента, поддержка законопроекта, петиции и т.п., для всего этого есть повод для
создания распределенной системы.
Необходимость создания распределенной системы заключается в недоверии участников голосования результатам централизованного голосования,
т.к. результаты централизованных систем подвержены искажению, неверного подсчета голосов, диверсиям и т.п.

**Содержание системы**.
Система должна содержать данные об участниках, сохраняя их приватность, но при этом иметь возможность провести
аудит голосования. Для того чтобы участниками являлись только граждане Украины системе необходим модуль
взаимодействия с центральными реестрами государства, как это было сделано в приложении "Дія".
Также система должна содержать механизм транзакций: их создание, верификация, валидация и подтверждение, для
выполнения основной задачи в процессах голосования (определенный голос это транзакция).
Еще необходим модуль синхронизации актуального состояния для актуализации данных во всех базах данных участников.
А также необходим модуль аккаунта пользователя, аккаунт должен быть прикреплен за пользователем в центрах МВС. Ну скорее всего :)

**Взаимодействие продукта**.
Каждый узел продукта взаимодействует с другим. Но, также
продукт должен взаимодействовать с центрами структур ~~власти~~слуг народа :)
Взаимодействие необходимо для отсеивания граждан других государств,
чтобы участниками системы были только граждане Украины.

**Функции продукта**.
Продукт должен исполнять несколько функций: существовать без центра принятий решений, быть прозрачным для
всех граждан Украины, доступным для проведения аудита и при этом обеспечивать высокий уровень приватности пользователей.
Еще организовать хранение и синхронизацию данных среди сторон, которые не доверяют друг другу.

**Требования к безопасности**.
Необходимо обеспечить проверку целостности данных (database integrity verification) для защиты от атак
нацеленных на попытки изменить данные. Это обеспечивается технологией blockchain, в цепочке блоков которой
каждый следующий блок содержит хэш-значение от предыдущего. Все попытки изменить данные влекут изменения
на всех последующих уровнях и будут замечены остальными участниками системы.
Также каждый участник должен иметь ключевую пару, приватный ключ из которой будет являться секретом пользователя.

**Характеристики пользователей**.
Пользователь системы это гражданин Украины и только.
Пользователь может выполнять роль как просто участника системы (голосовать), так и валидатора, инициатора петиции или голосования.

**Ограничения**.
Приватность: необходимость хранить все транзакции в общей базе данных,
но не раскрывать чувствительную информацию является сложной задачей распределенной системы.
Производительность: необходимость справляться с обработкой большого потока транзакций с необходимостью
синхронизации валидаторов которая занимает время.
Ответственность: определить виновного в случае конфликта или ошибки также является сложностью.

### Этап 2: классы KeyPair и Signature (update 24.06.2022)

 Использовал существующую библиотеку [RSA](https://github.com/vnstd/RSA), которая в свою очередь использует библиотеку [big-integer](https://www.npmjs.com/package/big-integer). Использовал только их .js файлы, которые немного поменял, т.к. они в изначальном виде для node.js.

 **RSA** (*rsa.js*)
  - удалил инструкции для *node.js*
  - сделал экспорт и импорт
  - добавил методы sign и verify для цифровой подписи, т.к. там было только шифрование и расшифрование

 **big-integer** (*BigInteger.js*)
  - удалил инструкции для *node.js*
  - сделал экспорт

 В файле *stage2.js* реализовал классы KeyPair и Signature, которые получились оболочкой для функций из библиотеки RSA.
  - класс KeyPair удобно хранит в полях пары {d, n} для приватного ключа и {e, n} для публичного ключа,
  - класс Signature удобно кодирует строку и использует ключи из экземпляра класса KeyPair.

 Сделал GUI составляющую для проверки работоспособности.
  - объект из операндов и результата печатается в консоли,
  - чтобы поменять длину ключей, нужно менять константу KEY_SIZE в файле *main.js*,
  - успешная подпись зависит от длины ключа и длины сообщения.

 Т.к. реализация разбита на модули нужно использовать локальный сервер. (CORS policy)
 Или что-то другое применить, может расширение [CORS Unblock](https://chrome.google.com/webstore/detail/cors-unblock/lfhmikememgdcahcdlaciloancbhjino?hl=ru) поможет, не пробовал :)

### Этап 3: класс Account (28.06.2022)

 Внутри класса **Account** использовал класс [SHA1](https://github.com/eapodporinov/sha1) из прошлых заданий.
 Также использовал класс KeyPair и Signature, которые реализовал на 2-ом этапе.
 Поскольку кейс это платформа голосования, то я предположил что аккаунту достаточно иметь только одну ключевую пару
 accountKeyPair для подписания формы (Form), которая будет соответствовать бюллетеню (Bulletin).
  - accountID: это хеш-значение публичного ключа,
  - forms: коллекция форм,
  - bulletins: коллекция бюллетеней.

  Класс Form это форма ответов для бюллетеня, содержит:
   - bulletinHash: идентификатор бюллетеня. Хэш получается из JSON-формата бюллетеня,
   - answers: коллекция ответов. Один ответ на один вопрос представлен отдельным объектом.

  Класс Bulletin - бюллетень, содержит:
   - name: название бюллетеня,
   - desciption: описание бюллетеня, забыл добавить в конструктор или сделать сеттер, не успел внимательно просмотреть до дедлайна, провтыкал :(
   - questions: коллекция вопросов. Вопрос представлен отдельным объектом с неким дополнительным параметром.

  Класс Question - вопрос в коллекции бюллетеня, содержит:
   - title: заголовок вопроса или сам вопрос,
   - answersCountLimit: дополнительный параметр, нужный для установки количества вариантов ответов, которые будет можно отметить,
   - answersVariants: коллекция вариантов ответов на этот вопрос.

  Класс Answer - служит для экземпляров ответа, содержит:
   - questionTitle: заголовок вопроса или сам вопрос,
   - answersVariants: коллекция ваших отмеченных вариантов в ответе на вопрос.

### Этап 4: класс Operation и Transaction (04.07.2022)

  Внутри модуля *stage4.js* реализовал классы *Operation* и *Transaction*. Класс *Operation* использует классы
  *Account*, *SHA1*, *Signature* из прошлых модулей. Также изменил класс *Account*: исправил ошибки и укоротил.
  И так, экземпляр класса *Operation* состоит из полей:
   - senderID: идентификатор аккаунта отправителя,
   - form: экземпляр класса *Form* соответственный бюллетеню,
   - bulletin: экземпляр класса *Bulletin* соответственный форме,
   - signature: цифровая подпись для заполненной формы, служит доказательством, что именно отправитель заполнял форму,
   - sendersPublicKey: публичный ключ отправителя для верификации полей *signature* и *senderID*.

  Метод **verifyOperation** верифицирует операцию. Этот метод нуждается в подробностях.
  Что он делает?
   - Сначала он хэширует *sendersPublicKey* и полученное сверяет с *senderID*, (**hasSendersVerify**).
   Результат подтверждает что от имени этого аккаунта была опубликована операция.
   - После верифицирует *signature* подавая на вход *form* в формате JSON и *sendersPublicKey*, (**hasSignatureVerify**).
   Таким образом обеспечивается целостность опубликованной формы.
   - Далее хэшируется бюллетень и полученное сверяется с *form.bulletinHash*, (**hasCorrectBulletin**).
   Этим действием подтверждается целостность бюллетеня и что form соответствует именно этому бюллетеню.
   - Затем сравнивается длина коллекций *form.answers* и *bulletin.questions*, (**hasAllAnswers**).
   Должен быть ответ на каждый вопрос.
   - Следом в цикле сравниваются заголовки вопросов, количество вариантов ответов с их лимитом, и включается ли
   вариант ответа в предложенные варианты ответов в бюллетене.
   Так подтверждается правильность заполнения формы.
   - В конце, если пройдены все проверки возвращается *true*.

  Класс **Transaction** состоит из полей:
   - setOfOperations: коллекция экземпляров *Operation*,
   - index: дополнительная произвольная строка для индивидуальности,
   - transactionID: хэш из конкатенации коллекции *setOfOperations* в формате JSON и поля *index*.

  В классе *Account* добавил метод *createPublishOp*, который возвращает новый экземпляр Operation с заполненными полями.

  В файле *main_stage4.js* сделал небольшой пример использования с выводом в консоль. Подключил этот файл к *index.html*.
  Генерация аккаунта с *keySize == 3000* занимает ~30-60 секунд (нужно подождать прогрузку). Может так и должно быть,
  а может мне попалась медленная RSA библиотека. Если длину ключа сделать меньше, например 2000, то цифровая подпись не покроет всю форму.

### Этап 5: класс Block и Blockchain (12.07.2022)

  В новом модуле *stage5.js* реализовал классы *Block* и *Blockchain*. Модуль использует классы *Operation* и *Transaction*
  из прошлого модуля *stage4.js*, а также функцию *SHA1(msg)* из модуля *sha1.js*.

  Класс *Block* состоит из полей:
   - blockID: идентификатор блока(хэш-значение). SHA1-хэш получается из конкатенации коллекции *setOfTransactions* в формате JSON и хеш-значения предыдущего блока.
   - setOfTransactions: коллекция транзакций.
   - prevHash: идентификатор(хэш-значение) предыдущего блока.

  Класс *Blockchain* включает поля:
   - blockHistory: коллекция валидных блоков, т. е. тех блоков которые прошли валидацию в методе *validateBlock*.
   - txDatabase: коллекция подтвержденных транзакций. Транзакции появляются в ней из блока, который прошел валидацию.

  Метод **initBlockchain** инициализирует экземпляр класса *Blockchain* с одним блоком(genesis block), который включает в себя одну транзакцию, которая не имеет операций и имеет поле *index* равное *'0000'*.

  Метод **validateBlock** проводит валидацию блока, а именно:
   - проверяет, равняется ли в этом блоке поле *prevHash* хэш-значению последнего блока в коллекции *blockHistory*.
   - проверяет каждую транзакцию в блоке на целостность путем SHA1-хэширования конкатенации коллекции *setOfOperations* в формате JSON и поля *index*.
   - проверяет, существует ли эта транзакция в коллекции *txDatabase*.
   - проводит валидацию каждой операции в каждой транзакции.
  Если все проверки пройдены, то включает блок в коллекцию *blockHistory*, а также все транзакции с блока в коллекцию *txDatabase* и возвращает *true*. Иначе при первой не пройденной проверки возвращает *false*.

  В файле *main_stage5.js* реализовал пример использования созданной системы. В этом примере все транзакции и все блоки включаться в *blockchain*, кроме *new_block_11* т.к. он содержит транзакцию *transaction_21* которая уже состоит в цепочке (*transaction_2*). Выводиться всё в консоль.

  P.S. под значением *поле* класса имеется ввиду *свойство* класса, сори за жаргон :) В принципе, что планировал и как себе всё представлял я и сделал, но чуть позже (скорее завтра) добавлю *view*-шку чтобы блоки и транзакции еще были в документе на страничке, а не только в консоли. Заранее прошу прощения за мой говнокод :)
